{"pages":[],"posts":[{"title":"hexo安装使用","text":"安装1npm install -g hexo-cli 创建项目123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 启动项目1hexo s -d 配置主题 主题地址123cd themesgit clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus更改站点配置文件_config.yml 的theme字段，为主题文件夹的名称 安装同步git工具12345678910111213141516171819201.安装npm install hexo-deployer-git --save2.申请ssh keyssh-keygen -t rsa -C &quot;邮箱地址&quot;3.将id_rsa.pub加入至github线上配置4.创建仓库，仓库名为：&lt;Github账号名称&gt;.github.io5.修改_config.yml（在站点目录下）。文件末尾修改为：deploy: type: git （二选一） repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git repo: https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 6.执行更新语法hexo g -d 评论功能-github（主题种有详细说明）申请引用跳转12345678910111213141516171819202122232425262728291.安装npm i --save gitment2.申请应用3.主页网址以及授权回调网址填写Application name:随便写Homepage URL:这个也可以随意写,就写你的博客地址就行Application description:描述,也可以随意写Authorization callback URL:这个必须写你的博客地址4.编辑主题配置文件themes/*/_config.yml:# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/comment: type: gitalk client_id: {刚才申请的ClientID} client_secret: {刚才申请的Client Secret} repo: &lt;Github账号名称&gt;.github.io owner: &lt;Github账号名称&gt; admin: - &lt;Github账号名称&gt; per_page: 20 # 可选填 distraction_free_mode: false # 可选填 pager_direction: last # 可选填 create_issue_manually: false # 可选填 proxy: # 可选填 flip_move_options: # 可选填 enable_hotkey: true # 可选填 加入折叠功能，符号之后的数据进行隐藏1&lt;!-- more --&gt; 好用的插件 主题地址使用admin进行文档编辑 流程图 照相机 详细请参考使用搭建语法嵌套st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","link":"/2020/04/10/hexo%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"},{"title":"git使用教程","text":"设置账户(需要和github账户设置一致)12git config --global user.name xxxgit config --global user.email xxx@foxmail.com 查看设置1git config --list 初始化仓库1git init 版本的创建与回退12345678添加文件git add code.txt设置版本信息git commit -m “版本1”回退版本git reset --hard HEAD^HEAD^表示当前版本的前一个版本，HEAD^^表示当前版本的前前个版本，也可以使用HEAD~1表示当前版本的前一个版本，HEAD~100表示当前版本的前100版本git reset --hard 版本号 查看历史12345678查看所有操作git reflog查看详细提交版本git log查看简化提交版本git log --pretty=oneline查看分支合并git log --pretty=oneline --graph 撤销操作（撤销commit）12345678git checkout -- 文件名git checkout ./*小结：场景1:当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用 命令git checkout – file场景2:当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步：第一步用命令git reset HEAD – file,就回到了场景1,第二步按场景1操作。场景3:已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节。 撤回add12git reset HEAD – filegit reset HEAD * 文件对比123456789101112131. git diff [文件名]将工作区中的文件和暂存区对应文件进行比较例：git diff test.txt2. git diff [本地库中文件历史记录(指针)] [文件名]将工作区中的文件和本地库历史记录比较例：git diff HEAD test.txt 比较最新一次修改git diff HEAD^ text.txt 比较上一次修改git diff 46e8eaa test.txt 比较历史记录号为 46e8eaa的修改3. git diff不带文件名，比较所有文件的修改 删除文件12345直接使用rm时，可以使用git checkout 撤回删除使用git rm，无法使用git checkout 撤回删除，但可以退回指定版本git reset --hard 命令rm 删除是永久删除，要恢复数据的话可以恢复/扫描硬盘；命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容 分支管理123456789101112131415161718192021222324252627282930313233查看分支git branch创建分支git checkout -b 分支名切换分支git checkout master（分支名）合并分支git merge 分支名删除分支git branch -d devgit默认会用fast forward模式，但是有些快速合并不能成功而且合并时没有冲突，这个时候git会帮我们在合并之后做一次新的提交，但这种模式下，删除分支后，会丢掉分支信息。【弹窗说明信息】强制禁用fast forward模式合并git merge --no-ff -m &quot;说明&quot; 分支名出现bug时，将当前工作环境保存git stashgit stash save &quot;备注&quot;查看保存的工作环境git stash list查看做了哪些改动git stash showgit stash pop stash@{1}还原工作环境git stash popgit stash pop stash@{1}删除工作环境git stash drop stash@{0} 查看git状态1234git status一般来说会显示需要提交的文件（uncommited）和未追踪的文件（untracked）uncommited：已有的，刚被修改尚未提交的untracked：原先没有的，新建的 详细请参考原文地址","link":"/2020/04/20/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"title":"打包压缩tar、gzip、bzip2、xz、zip、unzip","text":"gzipgzip是为了取代compress 并提供更好的压缩比，zcat/zmore/zless用来查看压缩文件12345-c ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；-d ：解压缩的参数；-t ：可以用来检验一个压缩文件的一致性～看看文件有无错误；-v ：可以显示出原文件/压缩文件的压缩比等信息；-# ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6 123456gzip glibc #不保留老文件gzip glibc -c &gt; glibc.gz #保留老文件gzip -d glibc.gz #解压缩不保留包文件gzip -dc glibc.gz &gt; /root/glibc #保留老文件并指定目录cat file1 file2 | gzip &gt; foo.gz #压缩多个文件gzip -cd old.gz | gzip &gt; new.gz #重新压缩 bzip2bzip2 比 gzip 提供更好的压缩比，bzcat/bzmore/bzless/bzgrep用来查看压缩文件123456-c ：将压缩的过程产生的数据输出到屏幕上！-d ：解压缩的参数-k ：保留原始文件，而不会删除原始的文件喔！-z ：压缩的参数 （默认值，可以不加）-v ：可以显示出原文件/压缩文件的压缩比等信息；-# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！ 123bzip2 glibcbzip2 -k glibc #保留原来bzip2 -dc glibc.bz2 &gt; /root/glibc #解压缩保留原来并重定向到文件 xz虽然 bzip2 已经具有很棒的压缩比，不过显然某些自由软件开发者还不满足，因此后来还推出了 xz 这个压缩比更高的软件，但是这个压缩命令压缩速度偏慢，如果不是对压缩率有特别需求，使用bzip2就够了！这个软件的用法也跟 gzip/bzip2 几乎一模一样。123456-d ：解压缩！-t ：测试压缩文件的完整性，看有没有错误-l ：列出压缩文件的相关信息-k ：保留原本的文件不删除～-c ：同样的，就是将数据由屏幕上输出的意思！-# ：同样的，也有较佳的压缩比的意思！ 123xz glibcxz -k glib c#保留原来xz -dc glibc.bz2 &gt; /root/glibc #解压缩保留原来并重定向到文件 tartar 是一个打包工具，只是同时还实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩。（配合上述压缩可以对文件目录进行打包并压缩）12345678910111213141516###bash####常用命令选项-c #打包-x #解包解压缩-t #查看-v #显示详细信息--exclude #排除-C #指定目录-T #从文件里获取需要打包的文件路径集合#3种压缩格式，压缩率从低到高#一般选用bzib2足已,xz压缩率高但是压缩速度偏慢-z gzip-j bzib2-J xz 1234567891011121314151617181920###bash###tar -cvf glibc.tar * #打包当前目录(注意不会打包隐藏文件如.ssh)#将当前目录所有打包为glibc.tar（过滤掉dir目录，扩展名为png,jpg的文件）tar -cvf glibc.tar * --exclude dir --exclude '*.png' --exclude '*.jpg'tar -cvzf glibc.tar.gz glibc a.txt #打包并以gzip压缩glibc，a.txttar -cvjf glibc.tar.bz2 glibc a.txt #打包并以bzib2压缩glibc，a.txttar -cvJf glibc.tar.xz glibc b.txt #打包并以xz压缩glibc，a.txt#解包--解压缩到/root目录tar -zxvf glibc.tar.gz -C /root #gziptar -jxvf glibc.tar.bz2 -C /root #bzib2tar -Jxvf glibc.tar.xz -C /root #xz#自动判断tar -xvf glibc.tar.xx -C /root#查看包内容tar -tvf glibc.tar.bz2 1234567891011121314151617###bash####只查看第一层文件目录tar --exclude=&quot;*/*&quot; -tvf glibc.tar.bz2#只打包隐藏文件(文件名第一个是.第二个是非.)tar -cvf /tmp/aaa.tar .[!.]*#打包全部（包含隐藏文件）#ls -A不会列出. ..两个目录tar -cvf /tmp/bbb.tar `ls -A`#配合find有时候更容易，比如只打包.c .h文件find ./ -name &quot;*.c&quot; -o -name &quot;*.h&quot; | xargs tar -cvjf /tmp/xxx.tar.bz2#内容太大还是不行(打包出来不准确或者报argument line too long)，可以分两步，先存文件，然后打包文件里指定的路径find ./ -name &quot;*.c&quot; -o -name &quot;*.h&quot; &gt; out.txttar -cvjf /tmp/xxx.tar.bz2 -T out.txt zip 命令为打包压缩命令，一般为了跟 windows 交互才会用的，不涉及 windows 推荐使用tar配合 gzip,bzip2,xzzip 压缩12345678910111213141516171819202122232425#常用命令选项-d 从压缩文件内删除指定的文件。-m 把文件移到压缩文件中。-0-9 压缩比-r 递归处理，所有文件和子目录一并处理。-x&lt;范本样式&gt; 压缩时排除符合条件的文件。-c 交互为每一个文件设置注释-z 交互多行注释,英文句话.来表示结束-e 交互设置密码-P 直接设置密码zip test.zip test.txt #添加压缩文件zip test.zip test1.txt #移动文件到压缩包zip -d test.zip test.txt #删除test.txtzip -r test.zip ./* #压缩当前全部文件到test.zipzip test2.zip test2/* #打包目录zip test3.zip tests/* -x tests/ln.log #压缩目录,除了tests/ln.logzip -r test.zip ./* -P 123 #设置密码(明文设置密码不太安全)zip -r test.zip ./* -e #交互设置密码(安全)#设置压缩比#-0不压缩，-9最高压缩，默认为-6zip test.zip test.txt -6 unzip 解压12345678910111213141516171819202122-d 指定目录-n 解压时不覆盖-o 不询问直接覆盖-l 显示压缩文件内所包含的文件。-v 显示压缩文件内所包含的文件。-x 指定不要处理哪些文件。-P 解压缩密码#解压到当前目录并直接覆盖unzip -o test1.zip#指定解压目录unzip test1.zip -d /tmp/#解压特定文件unzip test1.zip inc abc#查看zip包里所有文件unzip -l test.zip#只查看zip包里第1级文件或目录unzip -l test.zip -x '*/*/*' 详细请参考原文地址","link":"/2020/04/17/%E6%89%93%E5%8C%85%E5%8E%8B%E7%BC%A9tar%E3%80%81gzip%E3%80%81bzip2%E3%80%81xz%E3%80%81zip%E3%80%81unzip/"},{"title":"node模块规范","text":"CommonJS，ES6123export ———— import : 只有ES6支持的导出导入module.exports/exports ———— require: CommonJS支持的导出导入服务器端（node.js）规范主要是CommonJS 1234567891011121314151617181920212223242526272829commomJS模块：CommonJS定义的模块分为: 模块标识(module)、模块定义(exports) 、模块引用(require)1、获得的是缓存值，是对模块的拷贝2、可以对commomJS模块重新赋值3、可以对对象内部的值进行改变commonJS { let exports = module.exports exports是module.exports的一个引用，exports指向的是module.exports module.exports : 返回的是模块对象本身，返回的是一个类——————moudle.exports = [function name] exports. ... : 返回的是模块函数————————exports.[function name] = [function name] 运行阶段确定接口，运行时才会加载模块， 模块是对象，加载的是该对象， 加载的是整个模块，即将所有的接口全部加载进来， 输出是值的拷贝，即原来模块中的值改变不会影响已经加载的该值， this 指向当前模块}ES6模块：1、获得的是时时的值，是对模块的引用2、对ES6模块重新赋值会报错3、可以对对象内部的值进行改变ES6 { export: '可以输出多个，输出方式为 {}' ， export default : '只能输出一个 ，可以与export同时输出，但是不建议这么做'， 解析阶段确定对外输出的接口，解析阶段生成接口， 模块不是对象，加载的不是对象， 可以单独加载其中的某个接口（方法）， 静态分析，动态引用，输出的是值的引用，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变， this 指向undefined} 123456789var 组件名 = require('路径')抛出方式 调用方式exports.组件名 = new 组件名(); 组件名.类名.方法名module.exports = 组件名 new 组件名().方法名()module.exports = new 组件名() 组件名.方法名();es6模块规范export default new 组件名() 组件名.方法名(); import/requireexport default 组件名 new 组件名().方法名()————————————必须使用 import 组件名 from '路径'","link":"/2020/04/17/node%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83/"},{"title":"玉兔&#x2F;clash配置","text":"VPN官网 点击跳转12备用地址yutuc.cloud yutud.cloud Linux配置点击下载clash跳转至clash管理界面 123456789101112131415161718192021222324252627282930313233343536373839├── 用户目录│ ├── clash│ │ ├── clash-linux-amd64 启动│ │ ├── config.yml 配置文件 配置文件默认存放用户目录/.config/clash/config.yaml执行 cd &amp;&amp; mkdir clash 在 用户目录 下创建 clash 文件夹（哪个用户用就在哪个用户目录创建）一般个人的64位电脑下载 clash-linux-amd64.tar.gz即可。下载玉兔的配置文件，放至clash执行 ./clash-linux-amd64 -d . 即可启动 Clash，同时启动 HTTP 代理和 Socks5 代理。如提示权限不足，请执行 chmod +x clash-linux-amd64使用pm2启动pm2 start clash-linux-amd64查看状态pm2 ls查看日志pm2 logs clash-linux-amd64删除pm2 delete *判断是否成功启动：127.0.0.1:9090必须关闭防火墙/配置可访问此端口配置代理：sudo vim /etc/profileexport http_proxy=&quot;http://127.0.0.1:7890&quot;export HTTP_PROXY=&quot;http://127.0.0.1:7890&quot;export https_proxy=&quot;http://127.0.0.1:7890&quot;export HTTPS_PROXY=&quot;http://127.0.0.1:7890&quot;. /etc/profile","link":"/2020/04/19/vpn/"},{"title":"git，docker代理配置","text":"git1234567891011配置代理git config --global https.proxy 代理软件域名git config --global http.proxy 代理软件域名查看代理git config --global --get http.proxygit config --global --get https.proxy取消代理git config --global --unset http.proxygit config --global --unset https.proxy docker12345678910111213141516171.创建文件夹sudo mkdir -p /etc/systemd/system/docker.service.d2.新建配置文件，编辑配置vim /etc/systemd/system/docker.service.d/http-proxy.conf[Service]Environment=&quot;HTTPS_PROXY=http://127.0.0.1:1080/&quot; &quot;NO_PROXY=localhost,127.0.0.1,registry.docker-cn.com,hub-mirror.c.163.com&quot;3.刷新配置sudo systemctl daemon-reload4.重启dockersudo systemctl restart docker5.查看是否配置成功systemctl show --property=Environment docker","link":"/2020/04/18/%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"}],"tags":[],"categories":[{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo（博客）","slug":"工具/hexo（博客）","link":"/categories/%E5%B7%A5%E5%85%B7/hexo%EF%BC%88%E5%8D%9A%E5%AE%A2%EF%BC%89/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"打包&#x2F;压缩","slug":"linux/打包-压缩","link":"/categories/linux/%E6%89%93%E5%8C%85-%E5%8E%8B%E7%BC%A9/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"node","slug":"编程语言/node","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/node/"},{"name":"模块规范","slug":"编程语言/node/模块规范","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/node/%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83/"},{"name":"vpn（玉兔配置）","slug":"工具/vpn（玉兔配置）","link":"/categories/%E5%B7%A5%E5%85%B7/vpn%EF%BC%88%E7%8E%89%E5%85%94%E9%85%8D%E7%BD%AE%EF%BC%89/"},{"name":"配置","slug":"配置","link":"/categories/%E9%85%8D%E7%BD%AE/"},{"name":"配置代理","slug":"配置/配置代理","link":"/categories/%E9%85%8D%E7%BD%AE/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"}]}